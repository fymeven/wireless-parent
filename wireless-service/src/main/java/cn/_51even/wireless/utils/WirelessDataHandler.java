package cn._51even.wireless.utils;import cn._51even.wireless.model.AttrTLV;import cn._51even.wireless.model.SMSValue;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.math.BigInteger;import java.util.*;public class WirelessDataHandler {    private final static Logger logger = LoggerFactory.getLogger(WirelessDataHandler.class);    //协议中各字段所占位数    public enum MFLD{        Ver(2),//版本号        Type(2),//报文的类型        Rsv(4),//保留字段        SerialNo(4),//报文的序列号,由采集器随机生成        ReqID(4),//由公共云服务器在回复采集器时赋值，该值为应答采集器发送信息的 SerialNo字段        IPv4(8),//采集器IPV4地址        Port1(4),//采集器使用IPV4协议通讯时使用的端口号        Rsv2(4),//保留字段        IPv6(12),//采集器IPV6地址        Port2(4),//采集器使用IPV6协议通讯时使用的端口号        Key(12),//数据传输时的密文加密密钥        ErrCode(2),//设备或指令下发执行返馈错误状态码        AttrNum(2),//AttrNum字段表示其后边可变长度的属性字段属性的个数        Attr(-1),//可变长字段，由多个属性依次链接而成，每个属性的格式为TLV格式//        AttrType(2),//属性类型//        AttrLen(4),//属性长度,其值是整个属性三个字段AttrType、AttrLen、AttrValue的长度之和        ;        private Integer length;        MFLD(Integer length) {            this.length = length;        }        public Integer getLength() {            return length;        }        public static MFLD getEnum(String mfld){            MFLD[] values = MFLD.values();            for (MFLD value : values) {                if (Objects.equals(value.name(),mfld)){                    return value;                }            }            return null;        }    }    //版本号    public enum Ver{        //第一个版本        VERSION_1("01")        ;        public String value;        Ver(String value) {            this.value = value;        }        public String getValue() {            return value;        }    }    //报文的类型    public enum Type{        //采集器向云服务器发送的请求接入报文        REQ_JOIN("01"),        //云服务器对采集器请求接入报文的响应报文，并在属性字段里携带加密密钥        ACK_JOIN("02"),        //采集器向云服务器发送己采集数据报文        REQ_TRANSFDATA("03"),        //云服务器对采集器发送的采集数据收到应答报文，并在属性字段里携带是否需要重发等标记        ACK_TRANSFDATA("04"),        //采集器向云服务器发送的状态报文，并在属性字段里携带自身的功率、CUP使用率、等状态信息。        REQ_STATUS("05"),        //云服务器对采集器发送的状态信息响应报文        ACK_STATUS("06")        ;        public String value;        Type(String value) {            this.value = value;        }        public String getValue() {            return value;        }        public static Type getEnum(String value){            Type[] values = Type.values();            for (Type type : values) {                if (Objects.equals(type.value,value)){                    return type;                }            }            return null;        }    }    //设备或指令下发执行返馈错误状态码    public enum ErrCode{        //服务器接收数据正确，客户端可以删除该条数据        RE_OK("01"),        //服务器接收数据异常，客户端需重新发送该条数据        RE_ERR("02")        ;        public String value;        ErrCode(String value) {            this.value = value;        }        public String getValue() {            return value;        }    }    //报文属性字段    public enum Attr{        //发送采集数据        SMS("01"),        //心跳数据        IEEE802_DISCOVERY("02"),        //时间信息        SYNC_TIME("03"),        //升级起始指令（等待采集器准备好后再发数据）        UPGRADE_START("04"),        //升级数据        UPGRADE_DATA("05"),        //升级完成        UPGRADE_END("06"),        //重启指令        REBOOT("07"),        ;        public String value;        Attr(String value) {            this.value = value;        }        public String getValue() {            return value;        }        public static Attr getEnum(String value){            Attr[] values = Attr.values();            for (Attr attr : values) {                if (Objects.equals(attr.getValue(),value)){                    return attr;                }            }            return null;        }    }    //AttrType长度    private static final Integer AttrType_Length = 2;    //AttrLen长度    private static final Integer AttrLen_Length = 4;    //MFLD开始索引    public static final Map<MFLD,Integer> MFLD_OFFSET_START_MAP = new LinkedHashMap<>();    //MFLD结束索引    public static final Map<MFLD,Integer> MFLD_OFFSET_END_MAP = new LinkedHashMap<>();    static {        int offset = 0;        for (MFLD mfld : MFLD.values()) {            MFLD_OFFSET_START_MAP.put(mfld,offset);            offset += mfld.getLength();            MFLD_OFFSET_END_MAP.put(mfld,offset);        }    }    /**     * 存储协议固定字段内容     * @param hexString     * @param mfld     * @param value     */    public static void putMFLD(StringBuilder hexString,MFLD mfld,String value){        Integer offsetStart = MFLD_OFFSET_START_MAP.get(mfld);        Integer offsetEnd = MFLD_OFFSET_END_MAP.get(mfld);        hexString.replace(offsetStart,offsetEnd,value);    }    /**     * 获取协议固定字段内容     * @param hexString     * @param mfld     * @return     */    public static String getMFLD(StringBuilder hexString,MFLD mfld){        Integer offsetStart = MFLD_OFFSET_START_MAP.get(mfld);        if (MFLD.values()[MFLD.values().length-1] == mfld){            return hexString.substring(offsetStart);        }else {            Integer offsetEnd = MFLD_OFFSET_END_MAP.get(mfld);            return hexString.substring(offsetStart, offsetEnd);        }    }    /**     * 解析Attr报文属性字段     * @param attr     * @param offset     * @return     */    public static List<AttrTLV> parseAttr(StringBuilder attr, int offset){        try {            List<AttrTLV> attrTLVList = new ArrayList<>();            String attrType = attr.substring(offset, AttrType_Length);            offset += AttrType_Length;            String attrLen = attr.substring(offset, offset+AttrLen_Length);            offset += AttrLen_Length;            String binary = binary(RadiusUtil.hexStringToByte(attrLen), 10);            int attrLenNum = Integer.parseInt(binary) * 2;            Integer AttrValue_length = attrLenNum - AttrType_Length - AttrLen_Length;            String attrValue = attr.substring(offset, offset+AttrValue_length);            offset += AttrValue_length;            Attr attrTypeEnum = Attr.getEnum(attrType);            AttrTLV attrTLV = new AttrTLV();            attrTLV.setAttrType(attrTypeEnum);            attrTLV.setAttrLen(attrLenNum);            attrTLV.setAttrValue(attrValue);            attrTLVList.add(attrTLV);            if (attr.length() > offset+1){                List<AttrTLV> otherTLVList = parseAttr(attr, offset);                attrTLVList.addAll(otherTLVList);            }            return attrTLVList;        }catch (Exception e){            logger.error("解析Attr错误:",e);            return null;        }    }    /**     * 解析SMS采集数据属性值     * @param value     * @return     */    public static SMSValue parseSmsValue(String value){        SMSValue smsValue = new SMSValue();        int offset = 0;        return smsValue;    }//    public static String getAttr(StringBuilder hexString){//        Integer attrStartOffset = MFLD_OFFSET_END_MAP.get(MFLD.AttrNum);//        return hexString.toString().substring(attrStartOffset);//    }    public static void main(String[] args) {        String hex = "01050000000300000b6a71a40000000000000000000000000001020304050101010018003b0000000000005fd3900b0007f807f8078bf87f";        StringBuilder hexString = new StringBuilder(hex);        for (MFLD mfld : MFLD.values()) {            String value = getMFLD(hexString, mfld);            System.out.println(mfld.name()+":"+value);        }        putMFLD(hexString,MFLD.Port1,"2222");//        System.out.println(hexString.toString());        String attr = getMFLD(new StringBuilder(hex), MFLD.Attr);        System.out.println(attr);        System.out.println(attr.length());        List<AttrTLV> attrTLVList = parseAttr(new StringBuilder(attr), 0);        for (AttrTLV attrTLV : attrTLVList) {            System.out.println(String.format("Type:%s,Length:%s,Value:%s",attrTLV.getAttrType(),attrTLV.getAttrLen(),attrTLV.getAttrValue()));            System.out.println(String.format("value length:%s",attrTLV.getAttrValue().length()));        }    }    public static String binary(byte[] bytes, int radix){        return new BigInteger(1, bytes).toString(radix);// 这里的1代表正数    }}